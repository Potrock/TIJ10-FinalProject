#pragma config(Sensor, in1,    leftEye,        sensorReflection)
#pragma config(Sensor, in2,    rightEye,       sensorReflection)
#pragma config(Sensor, dgtl1,  distance,       sensorSONAR_inch)
#pragma config(Motor,  port1,           rightDrive,    tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          leftDrive,     tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void findLight() {
	int difference;
	wait1Msec(1000);

	motor[leftDrive] = -60; //Spin right
	motor[rightDrive] = 60;

	while(SensorValue[leftEye] > 200) {}; //Make sure Robot has found the light.

	motor[leftDrive] = 0; //Stops the robot from turning.
	motor[rightDrive] = 0;

	while(SensorValue[rightEye] > 25) { //Calculates what side of the Robot the light is on.
		difference = SensorValue[rightEye] - SensorValue[leftEye];

		if(difference > 0) {
			motor[leftDrive] = -60; //Turns robot towards light is, depending on what the difference between righteye and lefteye is.
			motor[rightDrive] = 60;
			} else if (difference < 0) {
			motor[leftDrive] = 60;
			motor[rightDrive] = -60;
			} else {
			motor[leftDrive] = 60;
			motor[rightDrive] = 60;
		}
		while(SensorValue[distance] == 5) { //Calls the Sonar sensor, robot will stop when the sensor (Not the front of the robot!) is 5 inches away from the light (Hopefully it'll detect the light and not the wall behind it. Might have to work on this some more.)
			motor[leftDrive] = 0;
			motor[rightDrive] = 0;
			motor[arm] = 63; //Arm goes down, will have to change this value once we get the hang of the Servo motor.
		}
	}
}
void returnMiddle() { //The function to return the robot to the center, this will be changed in the future to be more efficient or might switch this to Sonar sensor to be more reliable.
	motor[leftDrive] = -60;
	motor[rightDrive] = -60;
	wait1Msec(4000);
}

task main() { //The main task. Above all of this is the functions that this task calls upon, this is what is run when the robot starts.
	int timesComplete;
	timesComplete = 0;
	while(timesComplete < 8) {
		findLight();
		returnMiddle();
		timesComplete++;
	}
}
